name: Release Build

on:
  workflow_dispatch:
    inputs:
      major_version:
        description: 'å¤§ç‰ˆæœ¬å·'
        required: false
        default: '0'

permissions:
  contents: write

concurrency:
  group: release
  cancel-in-progress: true

jobs:
  prepare:
    name: Generate version
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate version from date
        id: version
        run: |
          MAJOR="${{ github.event.inputs.major_version || '0' }}"
          YYYYMMDD=$(date -u +%Y%m%d)
          HHMMSS=$(( $(date -u +%-H) * 10000 + $(date -u +%-M) * 100 + $(date -u +%-S) ))
          VERSION="${MAJOR}.${YYYYMMDD}.${HHMMSS}"
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=v${VERSION}" >> "$GITHUB_OUTPUT"
          echo "Generated version: ${VERSION} (tag: v${VERSION})"

      - name: Generate changelog
        id: changelog
        run: |
          # Find previous release tag
          PREV_TAG=$(git tag --sort=-creatordate | head -1 || true)
          echo "Previous tag: $PREV_TAG"

          if [ -n "$PREV_TAG" ]; then
            RANGE="${PREV_TAG}..HEAD"
          else
            RANGE="HEAD~20..HEAD"
          fi

          # Extract commit messages, categorize by prefix
          FEATURES=""
          FIXES=""
          OTHERS=""

          while IFS= read -r line; do
            # Skip merge commits and Co-Authored-By lines
            case "$line" in
              Merge*) continue ;;
              "") continue ;;
            esac

            if echo "$line" | grep -qiE '^feat'; then
              # Remove "feat: " or "feat(...): " prefix for cleaner display
              clean=$(echo "$line" | sed -E 's/^feat(\(.*\))?:\s*//')
              FEATURES="${FEATURES}- ${clean}\n"
            elif echo "$line" | grep -qiE '^fix'; then
              clean=$(echo "$line" | sed -E 's/^fix(\(.*\))?:\s*//')
              FIXES="${FIXES}- ${clean}\n"
            elif echo "$line" | grep -qiE '^refactor'; then
              clean=$(echo "$line" | sed -E 's/^refactor(\(.*\))?:\s*//')
              OTHERS="${OTHERS}- ${clean}\n"
            fi
          done < <(git log "$RANGE" --pretty=format:"%s" --no-merges 2>/dev/null || true)

          # Build changelog
          CHANGELOG=""
          if [ -n "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### âœ¨ æ–°åŠŸèƒ½\n\n${FEATURES}\n"
          fi
          if [ -n "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### ðŸ› ä¿®å¤\n\n${FIXES}\n"
          fi
          if [ -n "$OTHERS" ]; then
            CHANGELOG="${CHANGELOG}### ðŸ”§ ä¼˜åŒ–\n\n${OTHERS}\n"
          fi

          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="å¸¸è§„æ›´æ–°ä¸Žæ”¹è¿›\n"
          fi

          # Write to file for multi-line output
          echo -e "$CHANGELOG" > /tmp/changelog.md
          echo "changelog_file=/tmp/changelog.md" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ steps.version.outputs.tag }}
        run: |
          CHANGELOG=$(cat /tmp/changelog.md)
          gh release create "$TAG" \
            --repo "$GITHUB_REPOSITORY" \
            --title "Worktree Manager $TAG" \
            --notes "$(cat <<EOF
          ## æ›´æ–°å†…å®¹

          ${CHANGELOG}
          ---

          ### ä¸‹è½½

          - **macOS**: \`.dmg\` å®‰è£…åŒ… æˆ– \`.tar.gz\`
          - **Windows**: \`-setup.exe\` å®‰è£…åŒ…
          - **Linux**: \`.AppImage\` æˆ– \`.deb\`

          **è‡ªåŠ¨æ›´æ–°**: åº”ç”¨å†…ç½®è‡ªåŠ¨æ›´æ–°åŠŸèƒ½ï¼Œä¸‹æ¬¡å¯åŠ¨æ—¶ä¼šè‡ªåŠ¨æ£€æŸ¥æ–°ç‰ˆæœ¬ã€‚

          > **macOS é¦–æ¬¡å®‰è£…è¯´æ˜Žï¼š**
          > 1. ä¸‹è½½ \`.dmg\`ï¼Œæ‹–å…¥ Applications å®‰è£…
          > 2. é¦–æ¬¡æ‰“å¼€å¦‚æç¤ºæ— æ³•éªŒè¯å¼€å‘è€…ï¼Œè¯·**å³é”®ç‚¹å‡» app â†’ æ‰“å¼€**
          > 3. å¦‚ä»æ— æ³•æ‰“å¼€ï¼Œå‰å¾€ **ç³»ç»Ÿè®¾ç½® â†’ éšç§ä¸Žå®‰å…¨æ€§**ï¼Œåœ¨åº•éƒ¨æ‰¾åˆ°æç¤ºå¹¶ç‚¹å‡» **ä»è¦æ‰“å¼€**
          > 4. ä»¥ä¸Šæ–¹æ³•å‡æ— æ•ˆæ—¶ï¼Œæ‰“å¼€ç»ˆç«¯æ‰§è¡Œï¼š\`xattr -cr "/Applications/Worktree Manager.app"\`
          EOF
          )"

  release:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
          - os: ubuntu-22.04
          - os: windows-latest

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          cache-on-failure: true
          shared-key: release-build
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Add macOS targets
        if: runner.os == 'macOS'
        run: rustup target add aarch64-apple-darwin x86_64-apple-darwin

      - name: Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential pkg-config patchelf \
            libgtk-3-dev librsvg2-dev libayatana-appindicator3-dev \
            libwebkit2gtk-4.1-dev \
            libsoup-3.0-dev || sudo apt-get install -y --no-install-recommends libsoup2.4-dev

      - name: Set version
        shell: bash
        env:
          APP_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          node -e "
            const fs = require('fs');
            const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            pkg.version = process.env.APP_VERSION;
            fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');
          "
          node -e "
            const fs = require('fs');
            const conf = JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json', 'utf8'));
            conf.version = process.env.APP_VERSION;
            fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(conf, null, 2) + '\n');
          "
          sed -i.bak 's/^version = ".*"/version = "'"$APP_VERSION"'"/' src-tauri/Cargo.toml && rm -f src-tauri/Cargo.toml.bak
          echo "Set version to $APP_VERSION"

      - name: Cache npm downloads
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: npm-${{ runner.os }}-${{ hashFiles('package.json') }}
          restore-keys: npm-${{ runner.os }}-

      - name: Install frontend dependencies
        shell: bash
        run: |
          rm -rf node_modules package-lock.json
          npm install

      - name: Build Tauri App (macOS)
        if: runner.os == 'macOS'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build --target universal-apple-darwin

      - name: Build Tauri App (Windows)
        if: runner.os == 'Windows'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build --bundles nsis

      - name: Build Tauri App (Linux)
        if: runner.os == 'Linux'
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build --bundles appimage,deb

      - name: Prepare macOS assets
        if: runner.os == 'macOS'
        shell: bash
        env:
          TAG: ${{ needs.prepare.outputs.tag }}
        run: |
          set -euxo pipefail
          mkdir -p release-assets
          for path in \
            "src-tauri/target/universal-apple-darwin/release/bundle/macos" \
            "src-tauri/target/aarch64-apple-darwin/release/bundle/macos" \
            "src-tauri/target/release/bundle/macos"; do
            if [ -d "$path" ]; then
              TAR_GZ=$(find "$path" -maxdepth 1 -name "*.tar.gz" -type f | head -1 || true)
              if [ -n "$TAR_GZ" ]; then
                cp "$TAR_GZ" "release-assets/Worktree-Manager-${TAG}-macOS.tar.gz"
                [ -f "$TAR_GZ.sig" ] && cp "$TAR_GZ.sig" "release-assets/Worktree-Manager-${TAG}-macOS.tar.gz.sig"
                break
              fi
            fi
          done
          DMG=$(find src-tauri/target -name "*.dmg" -type f | head -1 || true)
          [ -n "$DMG" ] && cp "$DMG" "release-assets/Worktree-Manager-${TAG}-macOS.dmg"

      - name: Prepare Windows assets
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          TAG: ${{ needs.prepare.outputs.tag }}
        run: |
          New-Item -ItemType Directory -Force -Path release-assets | Out-Null
          $nsis = Get-ChildItem -Path 'src-tauri/target/release/bundle' -Recurse -Include *-setup.exe -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -ne $nsis) {
            Copy-Item $nsis.FullName (Join-Path release-assets "Worktree-Manager-$env:TAG-Windows-setup.exe")
            $sigPath = "$($nsis.FullName).sig"
            if (Test-Path $sigPath) {
              Copy-Item $sigPath (Join-Path release-assets "Worktree-Manager-$env:TAG-Windows-setup.exe.sig")
            }
          }
          $nsis_zip = Get-ChildItem -Path 'src-tauri/target/release/bundle' -Recurse -Include *-setup.nsis.zip -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($null -ne $nsis_zip) {
            Copy-Item $nsis_zip.FullName (Join-Path release-assets "Worktree-Manager-$env:TAG-Windows-setup.nsis.zip")
            $sigPath = "$($nsis_zip.FullName).sig"
            if (Test-Path $sigPath) {
              Copy-Item $sigPath (Join-Path release-assets "Worktree-Manager-$env:TAG-Windows-setup.nsis.zip.sig")
            }
          }

      - name: Prepare Linux assets
        if: runner.os == 'Linux'
        shell: bash
        env:
          TAG: ${{ needs.prepare.outputs.tag }}
        run: |
          set -euxo pipefail
          mkdir -p release-assets
          APPIMAGE=$(find src-tauri/target/release/bundle -name "*.AppImage" | head -1 || true)
          if [ -n "$APPIMAGE" ]; then
            cp "$APPIMAGE" "release-assets/Worktree-Manager-${TAG}-Linux.AppImage"
            [ -f "$APPIMAGE.sig" ] && cp "$APPIMAGE.sig" "release-assets/Worktree-Manager-${TAG}-Linux.AppImage.sig"
          fi
          DEB=$(find src-tauri/target/release/bundle -name "*.deb" | head -1 || true)
          [ -n "$DEB" ] && cp "$DEB" "release-assets/Worktree-Manager-${TAG}-Linux.deb"

      - name: Upload release assets
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.prepare.outputs.tag }}
        run: |
          for file in release-assets/*; do
            [ -f "$file" ] && gh release upload "$TAG" "$file" --clobber --repo "$GITHUB_REPOSITORY"
          done

      - name: List build bundles (debug)
        if: always()
        shell: bash
        run: find src-tauri/target -maxdepth 5 -type f \( -name "*.dmg" -o -name "*.msi" -o -name "*.deb" -o -name "*.AppImage" -o -name "*.tar.gz" -o -name "*.sig" -o -name "*.exe" \) 2>/dev/null || true

  assemble-latest-json:
    name: Assemble latest.json
    runs-on: ubuntu-22.04
    needs: [prepare, release]
    permissions:
      contents: write
    steps:
      - name: Download all release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.prepare.outputs.tag }}
        run: |
          set -euxo pipefail
          mkdir -p dl
          gh release download "$TAG" --dir dl --repo "$GITHUB_REPOSITORY"
          ls -la dl || true

      - name: Generate latest.json
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ needs.prepare.outputs.tag }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail
          PUB_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          base_url="https://github.com/$REPO/releases/download/$TAG"

          # Fetch release notes from GitHub Release for the updater dialog
          # Only include changelog (update content), not download/install instructions
          NOTES=$(gh release view "$TAG" --repo "$REPO" --json body -q '.body' 2>/dev/null || echo "Release $TAG")
          # Extract only the changelog section (between "## æ›´æ–°å†…å®¹" and "---")
          CHANGELOG_ONLY=$(echo "$NOTES" | sed -n '/^## æ›´æ–°å†…å®¹$/,/^---$/p' | sed '1d;$d' | sed '/^$/N;/^\n$/d')
          if [ -z "$CHANGELOG_ONLY" ]; then
            CHANGELOG_ONLY="$NOTES"
          fi
          NOTES_JSON=$(echo "$CHANGELOG_ONLY" | python3 -c 'import sys,json; print(json.dumps(sys.stdin.read()))')

          mac_url="" mac_sig=""
          win_url="" win_sig=""
          linux_url="" linux_sig=""

          shopt -s nullglob
          for sig in dl/*.sig; do
            base=${sig%.sig}
            fname=$(basename "$base")
            url="$base_url/$fname"
            sig_content=$(cat "$sig")
            case "$fname" in
              *.tar.gz) mac_url="$url"; mac_sig="$sig_content" ;;
              *.AppImage) linux_url="$url"; linux_sig="$sig_content" ;;
              *.nsis.zip) win_url="$url"; win_sig="$sig_content" ;;
            esac
          done

          {
            echo '{'
            echo "  \"version\": \"$VERSION\","
            echo "  \"notes\": ${NOTES_JSON},"
            echo "  \"pub_date\": \"$PUB_DATE\","
            echo '  "platforms": {'
            first=1
            if [ -n "$mac_url" ] && [ -n "$mac_sig" ]; then
              for key in darwin-aarch64 darwin-x86_64; do
                [ $first -eq 0 ] && echo ','
                echo "    \"$key\": {\"signature\": \"$mac_sig\", \"url\": \"$mac_url\"}"
                first=0
              done
            fi
            if [ -n "$win_url" ] && [ -n "$win_sig" ]; then
              [ $first -eq 0 ] && echo ','
              echo "    \"windows-x86_64\": {\"signature\": \"$win_sig\", \"url\": \"$win_url\"}"
              first=0
            fi
            if [ -n "$linux_url" ] && [ -n "$linux_sig" ]; then
              [ $first -eq 0 ] && echo ','
              echo "    \"linux-x86_64\": {\"signature\": \"$linux_sig\", \"url\": \"$linux_url\"}"
              first=0
            fi
            echo '  }'
            echo '}'
          } > latest.json
          echo "Generated latest.json:" && cat latest.json

      - name: Upload latest.json to release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ needs.prepare.outputs.tag }}
        run: gh release upload "$TAG" latest.json --clobber --repo "$GITHUB_REPOSITORY"
